#define _REENTRANT
#define _USE_MATH_DEFINES

#include <math.h>
#include <pthread.h>
#include "acc.h"
#include "IMU.h"
#include "MotorController.h"
#include "matrix.h"  
#include "utility.h"
#include <iostream>
#include <fstream>
#include <string>
#include <vector>

#include <stdlib.h>
#include <stdio.h>
#include <netdb.h>
#include <sys/socket.h>
#include <arpa/inet.h>

#include "RTIMULib.h"

#define BUFSIZE 2048
#define SERVICE_PORT	21234	/* hard-coded port number */

using namespace std;
using namespace math;

#ifndef _NO_TEMPLATE
typedef matrix<double> Matrix;
#else
typedef matrix Matrix;
#endif

Acc acc1;
Acc acc2;
Acc acc3;
Acc acc4;

vector<double> joints;

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

void * thread1(void *arg)
{
	// SOCKET SETUP
	struct sockaddr_in myaddr;	/* our address */
	struct sockaddr_in remaddr;	/* remote address */
	socklen_t addrlen = sizeof(remaddr);		/* length of addresses */
	int recvlen;			/* # bytes received */
	int fd;				/* our socket */
	int msgcnt = 0;			/* count # of messages we received */
	char buf[BUFSIZE];	/* receive buffer */
	
	/* create a UDP socket */
	if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
		perror("cannot create socket\n");
		return 0;
	}

	/* bind the socket to any valid IP address and a specific port */
	memset((char *)&myaddr, 0, sizeof(myaddr));
	myaddr.sin_family = AF_INET;
	myaddr.sin_addr.s_addr = htonl(INADDR_ANY);
	myaddr.sin_port = htons(SERVICE_PORT);

	if (bind(fd, (struct sockaddr *)&myaddr, sizeof(myaddr)) < 0) {
		perror("bind failed");
		return 0;
	}
	printf("waiting on port %d\n", SERVICE_PORT);
	// END SOCKET SETUP


	// BEGIN ACCELEROMETER SETUP
	int v=(int)arg;
	
	acc1.initialize(1);
	acc2.initialize(2);
	acc3.initialize(3);
	acc4.initialize(4);
	
	vector<int> acc_raw1(3);
	vector<int> acc_raw2(3);
	vector<int> acc_raw3(3);
	vector<int> acc_raw4(3);
	
	string line;
	ofstream acc1OUT(createOutFile("-acc1OUT.csv"));
	ofstream acc2OUT(createOutFile("-acc2OUT.csv"));
	ofstream acc3OUT(createOutFile("-acc3OUT.csv"));
	ofstream acc4OUT(createOutFile("-acc4OUT.csv"));
	// END ACCELEROMETER SETUP	
	
	
	// BEGIN WMRA CONTROLLER SETUP
	MotorController controller;
	controller.initialize();
	vector<double> joints(8);
	
	ofstream jointOUT(createOutFile("-jointOUT.csv"));
	// END WMRA CONTROLLER SETUP
	

	// BEGIN IMU SETUP
	int sampleCount = 0;
	int sampleRate = 0;
	uint64_t rateTimer;
	uint64_t displayTimer;
	uint64_t now;
	double IMU_pitch, IMU_roll, IMU_yaw;
	
	//  using RTIMULib here allows it to use the .ini file generated by RTIMULibDemo.
	
	RTIMUSettings *settings = new RTIMUSettings("RTIMULib");
	
	RTIMU *imu = RTIMU::createIMU(settings);
	
	if ((imu == NULL) || (imu->IMUType() == RTIMU_TYPE_NULL)) {
		printf("No IMU found\n");
		exit(1);
    	}
	imu->IMUInit();
	
	
	rateTimer = displayTimer = RTMath::currentUSecsSinceEpoch();//  set up for rate timer

	ofstream IMU_OUT(createOutFile("-IMU_OUT.csv"));
	// END IMU SETUP

	
	while(1)
	{
		if(v!=0)
		{
			sleep(v);
			cout << endl;
		}
		
		// WAIT FOR MESSAGE	
/*		recvlen = recvfrom(fd, buf, BUFSIZE, 0, (struct sockaddr *)&remaddr, &addrlen);
		if (recvlen > 0) {
			buf[recvlen] = 0;
			printf("received message: \"%s\" (%d bytes)\n", buf, recvlen);
		}
		else
			printf("uh oh - something went wrong!\n");
*/		
		
		while(imu->IMURead()) {
			RTIMU_DATA imuData = imu->getIMUData();
			
			IMU_pitch = imuData.fusionPose.x();
			IMU_roll = imuData.fusionPose.y();
			IMU_yaw = imuData.fusionPose.z();
		}

		IMU_OUT << IMU_pitch << ", " << IMU_roll << ", " << IMU_yaw << endl;

//		cout << "\n\t IMU Pitch: " << IMU_pitch << "\tRoll: " << IMU_roll << "\tYaw: " << IMU_yaw << endl;

		// ACCELEROMETER 1 READ DATA
		acc1.data_raw(acc_raw1[0],acc_raw1[1],acc_raw1[2]);
		acc1OUT << acc_raw1[0] << ", " << acc_raw1[1] << ", " << acc_raw1[2] << endl;

		// ACCELEROMETER 2 READ DATA		
		acc2.data_raw(acc_raw2[0],acc_raw2[1],acc_raw2[2]);
		acc2OUT << acc_raw2[0] << ", " << acc_raw2[1] << ", " << acc_raw2[2] << endl;
		
		// ACCELEROMETER 3 READ DATA	
		acc3.data_raw(acc_raw3[0],acc_raw3[1],acc_raw3[2]);
		acc3OUT << acc_raw3[0] << ", " << acc_raw3[1] << ", " << acc_raw3[2] << endl;
		
		// ACCELEROMETER 4 READ DATA		
		acc4.data_raw(acc_raw4[0],acc_raw4[1],acc_raw4[2]);
		acc4OUT << acc_raw4[0] << ", " << acc_raw4[1] << ", " << acc_raw4[2] << endl;
		
		if(controller.isInitialized())
		{
			joints[0] = controller.readPos(1);
			joints[1] = controller.readPos(2);
			joints[2] = controller.readPos(3);
			joints[3] = controller.readPos(4);
			joints[4] = controller.readPos(5);
			joints[5] = controller.readPos(6);
			joints[6] = controller.readPos(7);
			jointOUT << joints[0] << ", " << joints[1] << ", " << joints[2] << ", " << joints[3] << ", " << joints[4] << ", " << joints[5] << ", " << joints[6] << endl;
		}
		else
		{
			joints[0] = 0.0;
			joints[1] = 0.0;
			joints[2] = 0.0;
			joints[3] = 0.0;
			joints[4] = 0.0;
			joints[5] = 0.0;
			joints[6] = 0.0;	
		}
			
		// SENDING DATA		
		if(controller.isInitialized())
			sprintf(buf, "%f %f %f %d %d %d %d %d %d %d %d %d %d %d %d %d %f %f %f %f %f %f %f", IMU_pitch, IMU_roll, IMU_yaw, acc_raw1[0], acc_raw1[1], acc_raw1[2],acc_raw2[0], acc_raw2[1], acc_raw2[2],acc_raw3[0], acc_raw3[1], acc_raw3[2], acc_raw4[0], acc_raw4[1], acc_raw4[2], 1, joints[0], joints[1], joints[2], joints[3], joints[4], joints[5], joints[6]);
		else
			sprintf(buf, "%f %f %f %d %d %d %d %d %d %d %d %d %d %d %d %d %f %f %f %f %f %f %f", IMU_pitch, IMU_roll, IMU_yaw, acc_raw1[0], acc_raw1[1], acc_raw1[2],acc_raw2[0], acc_raw2[1], acc_raw2[2],acc_raw3[0], acc_raw3[1], acc_raw3[2], acc_raw4[0], acc_raw4[1], acc_raw4[2], 0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);		
		printf("sending response \"%s\"\n", buf);
//		if (sendto(fd, buf, strlen(buf), 0, (struct sockaddr *)&remaddr, addrlen) < 0)
//			perror("sendto");	
	}
	return(NULL);
}

int main( int argc, const char* argv[] )
{
	double x1, y1, z1, J1, J2;
	int choice=0;
	int viewer = 0;
	
	if(argc != 2)
		cout << "Need Input Value for Debugging\n" << endl;
	else
		viewer = atoi(argv[1]);
		
	pthread_t	tid;
	pthread_create(&tid, NULL, &thread1, (void *)viewer);

	pthread_join(tid, 0);
	return 1;
}
